# Introduction
- Fairy tales are more than true: not because they tell us that dragons exist, but because they tell us that dragons can be beaten.
- A book on implementing interpreters for programming languages, also a book on how to design a language worth implementing.
- Will walk step by step through two complete interpreters for a full-featured language.
- This text is lighter on theory than others.
- my goal for you: to come away with a solid intuition of how a real language lives and breathes.


- Implementing a language is a real test of programming skill. The code is complex and performance critical.
- We will abstain from using Lex and Yacc here. We’ll write everything by hand.
- Each chapter ends with a few exercises to help you learn more than what’s in the chapter. They will make you research other languages, figure out how to implement features, or otherwise get you out of your comfort zone.
- A compiler reads files in one language, translates them, and outputs files in another language. You can implement a compiler in any language, including the same language it compiles, a process called **self-hosting**.
- if you have another compiler for your language written in some other language, you use that one to compile your compiler once. Now you can use the compiled version of your own compiler to compile future versions of itself, and you can discard the original one compiled from the other compiler. This is called **bootstrapping**.
- First Interpreter: Jlox, in Java. Because it is Hugely popular, object oriented.
- it work by taking advantage of the Java virtual machine’s own runtime facilities. We want to learn how Java itself implements those things.
- Second interpreter: clox, in C. Perfect for understanding how an implementation really works, all the way down to bytes in memory and code flowing through CPU.
- You may need to check an introduction to C programming book, you need to be comfortable with it.
- Forced to implement for ourselves all the things Java gave us for free, we’ll write our own dynamic array and hash table. We’ll decide how objects are represented in memory, and build a garbage collector to reclaim them.
- By the end, we’ll have a robust, accurate, fast interpreter for our language, able to keep up with other professional caliber implementations out there.


Challenge_1 : domain specific languages used in his implementation (HTML, CSS, SCSS, MarkDown, makefile, jinja2)

 